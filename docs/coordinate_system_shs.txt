
SHS Renderer Coordinate System Conventions
===========================================

Handedness:     Left-handed (LH)
NDC z range:    [-1.0, 1.0]


Pipeline:
    Model -> World -> View -> Projection -> NDC -> Screen -> shs::Canvas


Model space 3D coordinate system:
    origin is (0,0,0) and center of all vertices of individual model
    x is to the right
    y is to the up
    z is to the forward


World space 3D coordinate system:
    origin is (0,0,0) and center of all models
    x is to the right
    y is to the up
    z is to the forward


View space 3D coordinate system:
    origin is (0,0,0) and viewer is at origin
    x is to the right
    y is to the up
    z is to the forward


Projection space:
    simulates camera perspective
    x is to the right
    y is to the up
    z is to the forward
    w is used for normalization


Clip space / NDC (Normalized Device Coordinates):
    axes mapped to range [-1.0, 1.0], scaled by z_near and z_far
    x is to the right
    y is to the up
    z is to the forward

    glm::vec3 point_in_NDC = glm::vec3(point_in_CLIP_SPACE) / point_in_CLIP_SPACE.w;


Screen space 2D:
    maps x in NDC[-1, 1] -> [0, SCREEN_WIDTH]
    maps y in NDC[-1, 1] -> [SCREEN_HEIGHT, 0]
    origin (0,0) is at top-left corner
    x is left to right
    y is top to bottom


shs::Canvas 2D:
    origin (0,0) is at left-bottom corner
    x is left to right
    y is bottom to up
    rasterization in software path happens here


Screen -> Canvas conversion:
    x_canvas = x_screen
    y_canvas = SCREEN_HEIGHT - y_screen


Backend rules:
    Software:
        NDC +Y maps to canvas +Y directly.
        During present/upload, rows are vertically flipped to screen(top-left) space.
    Vulkan:
        viewport uses y = framebuffer_height and height = -framebuffer_height
        so NDC +Y still means "up" visually, matching software convention.


Cross product in LH:
    x cross y = +z
    (0,0,1) is "forward" direction


GLM usage:
    All matrices are column-major (GLM default).
    glm::perspectiveLH_NO for left-handed + NDC [-1..+1] z-range.
    glm::lookAtLH for left-handed view matrix.
