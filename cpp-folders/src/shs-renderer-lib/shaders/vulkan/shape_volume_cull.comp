#version 450
#extension GL_GOOGLE_include_directive : require

#include "common/math.glsl"

// Deprecated compatibility shader name.
// Canonical file: shape_cell_cull.comp.

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Keep enum values aligned with shs::ShapeVolumeKind.
const uint SHAPE_KIND_SPHERE = 0u;
const uint SHAPE_KIND_AABB = 1u;
const uint SHAPE_KIND_OBB = 2u;
const uint SHAPE_KIND_CAPSULE = 3u;
const uint SHAPE_KIND_CONE = 4u;
const uint SHAPE_KIND_CONE_FRUSTUM = 5u;
const uint SHAPE_KIND_CYLINDER = 6u;
const uint SHAPE_KIND_CONVEX_POLY = 7u;
const uint SHAPE_KIND_KDOP18 = 8u;
const uint SHAPE_KIND_KDOP26 = 9u;
const uint SHAPE_KIND_SWEPT_CAPSULE = 10u;
const uint SHAPE_KIND_SWEPT_OBB = 11u;
const uint SHAPE_KIND_MESHLET_HULL = 12u;
const uint SHAPE_KIND_CLUSTER_HULL = 13u;
const uint SHAPE_PAYLOAD_FLAG_HAS_AUX_VERTICES = 1u << 0;
const uint SHAPE_PAYLOAD_FLAG_BROAD_FALLBACK = 1u << 1;

const uint CULL_OUTSIDE = 0u;
const uint CULL_INTERSECTING = 1u;
const uint CULL_INSIDE = 2u;

struct ShapeVolumeGPU
{
    vec4 center_radius;
    vec4 p0;
    vec4 p1;
    vec4 p2;
    vec4 p3;
    vec4 p4;
    vec4 p5;
    uvec4 meta;
};

struct ConvexCellGPU
{
    uvec4 meta;
    vec4 planes[16];
};

struct CullJobGPU
{
    uint shape_index;
    uint cell_index;
    uint out_index;
    uint flags;
};

layout(set = 0, binding = 0, std430) readonly buffer ShapesBuffer
{
    ShapeVolumeGPU shapes[];
} g_shapes;

layout(set = 0, binding = 1, std430) readonly buffer CellsBuffer
{
    ConvexCellGPU cells[];
} g_cells;

layout(set = 0, binding = 2, std430) readonly buffer JobsBuffer
{
    CullJobGPU jobs[];
} g_jobs;

layout(set = 0, binding = 3, std430) buffer ResultsBuffer
{
    uint out_classes[];
} g_results;

layout(set = 0, binding = 4, std430) readonly buffer AuxVerticesBuffer
{
    vec4 aux_vertices[];
} g_aux_vertices;

layout(push_constant) uniform CullPush
{
    // x: job_count, y: shape_count, z: cell_count, w: flags
    uvec4 counts;
    // x: outside_epsilon, y: inside_epsilon
    vec4 eps;
} pc;

float plane_signed_distance(vec4 plane, vec3 p)
{
    return dot(plane.xyz, p) + plane.w;
}

float support_sphere(vec3 center, float radius, vec3 dir)
{
    return dot(dir, center) + max(radius, 0.0) * length(dir);
}

float support_aabb(vec3 bmin, vec3 bmax, vec3 dir)
{
    vec3 v = vec3(
        dir.x >= 0.0 ? bmax.x : bmin.x,
        dir.y >= 0.0 ? bmax.y : bmin.y,
        dir.z >= 0.0 ? bmax.z : bmin.z
    );
    return dot(dir, v);
}

float support_obb(vec3 center, vec3 axis_x, float ex, vec3 axis_y, float ey, vec3 axis_z, float ez, vec3 dir)
{
    vec3 ext = max(vec3(ex, ey, ez), vec3(0.0));
    return dot(dir, center) +
           ext.x * abs(dot(dir, axis_x)) +
           ext.y * abs(dot(dir, axis_y)) +
           ext.z * abs(dot(dir, axis_z));
}

float support_capsule(vec3 a, vec3 b, float radius, vec3 dir)
{
    float end = max(dot(dir, a), dot(dir, b));
    return end + max(radius, 0.0) * length(dir);
}

float support_cone(vec3 apex, vec3 axis, float height, float radius, vec3 dir)
{
    vec3 ax = shs_normalize_or(axis, vec3(0.0, -1.0, 0.0));
    vec3 base = apex + ax * max(height, 0.0);
    float ax_dot = dot(dir, ax);
    vec3 perp = dir - ax * ax_dot;
    float disk = dot(dir, base) + max(radius, 0.0) * length(perp);
    return max(dot(dir, apex), disk);
}

float support_cone_frustum(vec3 apex, vec3 axis, float near_d, float far_d, float near_r, float far_r, vec3 dir)
{
    vec3 ax = shs_normalize_or(axis, vec3(0.0, -1.0, 0.0));
    float nd = max(near_d, 0.0);
    float fd = max(far_d, nd);
    vec3 near_c = apex + ax * nd;
    vec3 far_c = apex + ax * fd;
    float ax_dot = dot(dir, ax);
    vec3 perp = dir - ax * ax_dot;
    float perp_len = length(perp);
    float near_s = dot(dir, near_c) + max(near_r, 0.0) * perp_len;
    float far_s = dot(dir, far_c) + max(far_r, 0.0) * perp_len;
    return max(near_s, far_s);
}

float support_cylinder(vec3 center, vec3 axis, float half_h, float radius, vec3 dir)
{
    vec3 ax = shs_normalize_or(axis, vec3(0.0, 1.0, 0.0));
    float ax_dot = dot(dir, ax);
    vec3 perp = dir - ax * ax_dot;
    return dot(dir, center) + max(half_h, 0.0) * abs(ax_dot) + max(radius, 0.0) * length(perp);
}

float support_swept_capsule(vec3 a0, vec3 b0, vec3 a1, vec3 b1, float r0, float r1, vec3 dir)
{
    float len = length(dir);
    float s0 = max(dot(dir, a0), dot(dir, b0)) + max(r0, 0.0) * len;
    float s1 = max(dot(dir, a1), dot(dir, b1)) + max(r1, 0.0) * len;
    return max(s0, s1);
}

float support_poly_vertices(uint offset, uint count, vec3 dir, vec4 broad_center_radius)
{
    if (count == 0u) return support_sphere(broad_center_radius.xyz, broad_center_radius.w, dir);

    float best = -1e30;
    for (uint i = 0u; i < count; ++i)
    {
        vec3 v = g_aux_vertices.aux_vertices[offset + i].xyz;
        best = max(best, dot(dir, v));
    }
    return best;
}

float support_shape_max(ShapeVolumeGPU shape, vec3 dir)
{
    uint kind = shape.meta.x;
    uint aux_offset = shape.meta.y;
    uint aux_count = shape.meta.z;
    uint flags = shape.meta.w;

    if (kind == SHAPE_KIND_SPHERE)
    {
        return support_sphere(shape.center_radius.xyz, shape.center_radius.w, dir);
    }
    if (kind == SHAPE_KIND_AABB)
    {
        return support_aabb(shape.p0.xyz, shape.p1.xyz, dir);
    }
    if (kind == SHAPE_KIND_OBB)
    {
        return support_obb(shape.center_radius.xyz, shape.p0.xyz, shape.p0.w, shape.p1.xyz, shape.p1.w, shape.p2.xyz, shape.p2.w, dir);
    }
    if (kind == SHAPE_KIND_CAPSULE)
    {
        return support_capsule(shape.p0.xyz, shape.p1.xyz, shape.p2.x, dir);
    }
    if (kind == SHAPE_KIND_CONE)
    {
        return support_cone(shape.p0.xyz, shape.p1.xyz, shape.p1.w, shape.p2.x, dir);
    }
    if (kind == SHAPE_KIND_CONE_FRUSTUM)
    {
        return support_cone_frustum(shape.p0.xyz, shape.p1.xyz, shape.p1.w, shape.p2.x, shape.p2.y, shape.p2.z, dir);
    }
    if (kind == SHAPE_KIND_CYLINDER)
    {
        return support_cylinder(shape.p0.xyz, shape.p1.xyz, shape.p1.w, shape.p2.x, dir);
    }
    if (kind == SHAPE_KIND_SWEPT_CAPSULE)
    {
        return support_swept_capsule(shape.p0.xyz, shape.p1.xyz, shape.p2.xyz, shape.p3.xyz, shape.p4.x, shape.p4.y, dir);
    }

    // Convex poly-like path: ConvexPolyhedron / KDOP / SweptOBB / Meshlet / Cluster.
    if ((flags & SHAPE_PAYLOAD_FLAG_HAS_AUX_VERTICES) == 0u)
    {
        return support_sphere(shape.center_radius.xyz, shape.center_radius.w, dir);
    }
    return support_poly_vertices(aux_offset, aux_count, dir, shape.center_radius);
}

uint classify_shape_cell(ShapeVolumeGPU shape, ConvexCellGPU cell, float outside_eps, float inside_eps)
{
    bool fully_inside = true;
    uint plane_count = min(cell.meta.x, 16u);
    for (uint i = 0u; i < plane_count; ++i)
    {
        vec3 n = cell.planes[i].xyz;
        float d = cell.planes[i].w;

        float max_d = support_shape_max(shape, n) + d;
        if (max_d < -outside_eps) return CULL_OUTSIDE;

        float min_d = -support_shape_max(shape, -n) + d;
        if (min_d < inside_eps) fully_inside = false;
    }
    return fully_inside ? CULL_INSIDE : CULL_INTERSECTING;
}

void main()
{
    uint job_id = gl_GlobalInvocationID.x;
    uint job_count = pc.counts.x;
    if (job_id >= job_count) return;

    CullJobGPU job = g_jobs.jobs[job_id];
    if (job.shape_index >= pc.counts.y || job.cell_index >= pc.counts.z)
    {
        g_results.out_classes[job.out_index] = CULL_INTERSECTING;
        return;
    }

    ShapeVolumeGPU shape = g_shapes.shapes[job.shape_index];
    ConvexCellGPU cell = g_cells.cells[job.cell_index];
    float outside_eps = max(pc.eps.x, 0.0);
    float inside_eps = max(pc.eps.y, 0.0);
    uint plane_count = min(cell.meta.x, 16u);

    // Match CPU conservative behavior for invalid cells.
    if (plane_count == 0u)
    {
        g_results.out_classes[job.out_index] = CULL_INTERSECTING;
        return;
    }

    // Broad-phase sphere quick reject.
    float sphere_max = support_sphere(shape.center_radius.xyz, shape.center_radius.w, cell.planes[0].xyz) + cell.planes[0].w;
    // Use full classify after one cheap probe. (Keeps broad sphere data useful even when exact path exists.)
    if (sphere_max < -outside_eps)
    {
        g_results.out_classes[job.out_index] = CULL_OUTSIDE;
        return;
    }

    g_results.out_classes[job.out_index] = classify_shape_cell(shape, cell, outside_eps, inside_eps);
}
