#version 450
#extension GL_GOOGLE_include_directive : require

#include "common/light_constants.glsl"
#include "common/culling_light_struct.glsl"

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform CameraUBO
{
    mat4 view;
    mat4 proj;
    mat4 view_proj;
    vec4 camera_pos_time;
    vec4 sun_dir_intensity;
    uvec4 screen_tile_lightcount; // x: width, y: height, z: tiles_x, w: light_count
    uvec4 params;                 // x: tiles_y, y: max_per_tile, z: tile_size, w: culling_mode
    uvec4 culling_params;         // x: cluster_z_slices, y: lighting_technique, z: semantic_debug_mode, w: semantic_id
    vec4 depth_params;            // x: near, y: far
    vec4 exposure_gamma;          // x: exposure, y: gamma
    mat4 sun_shadow_view_proj;
    vec4 sun_shadow_params;
    vec4 sun_shadow_filter;
} ubo;

layout(set = 0, binding = 1, std430) readonly buffer LightBuffer
{
    CullingLightGPU lights[];
} light_buffer;

layout(set = 0, binding = 2, std430) buffer TileCounts
{
    uint tile_counts[];
};

layout(set = 0, binding = 3, std430) buffer TileIndices
{
    uint tile_indices[];
};

// Per-tile linear view-space depth range (+Z forward), produced by depth reduce.
layout(set = 0, binding = 4, std430) readonly buffer TileDepthRanges
{
    vec2 tile_depth_ranges[];
};

vec4 resolve_cull_sphere(CullingLightGPU light)
{
    vec4 s = light.cull_sphere;
    uint light_type = light.type_shape_flags.x;
    float shading_range = max(light.position_range.w, 0.0);

    // Safety net: keep cull bounds conservative even if a producer packed
    // too-tight bounds for anisotropic lights.
    if (light_type == SHS_LIGHT_TYPE_RECT_AREA)
    {
        float hx = max(light.up_shape_x.w, 0.0);
        float hy = max(light.shape_attenuation.x, 0.0);
        vec3 dir = normalize(light.direction_spot.xyz);
        vec3 c = light.position_range.xyz + dir * (shading_range * 0.5);
        float r = length(vec3(hx + shading_range, hy + shading_range, max(shading_range * 0.5, 0.001)));
        if (s.w <= 0.0 || s.w < r)
        {
            s = vec4(c, r);
        }
    }
    else if (light_type == SHS_LIGHT_TYPE_TUBE_AREA)
    {
        float half_len = max(light.up_shape_x.w, 0.0);
        float r = half_len + shading_range;
        if (s.w <= 0.0 || s.w < r)
        {
            s = vec4(light.position_range.xyz, r);
        }
    }
    else if (light_type == SHS_LIGHT_TYPE_SPOT || light_type == SHS_LIGHT_TYPE_POINT)
    {
        if (s.w <= 0.0 || s.w < shading_range)
        {
            s = vec4(light.position_range.xyz, shading_range);
        }
    }

    if (s.w > 0.0) return s;

    vec3 bmin = light.cull_aabb_min.xyz;
    vec3 bmax = light.cull_aabb_max.xyz;
    vec3 ext = max((bmax - bmin) * 0.5, vec3(0.0));
    float r = length(ext);
    if (r > 0.0)
    {
        return vec4((bmin + bmax) * 0.5, r);
    }

    return vec4(light.position_range.xyz, max(light.position_range.w, 0.0));
}

bool project_light_screen(vec3 pos_ws, float radius_ws, uint width, uint height, out vec2 center_px, out float radius_px, out float view_depth)
{
    vec4 view4 = ubo.view * vec4(pos_ws, 1.0);
    float near_z = max(ubo.depth_params.x, 0.001);
    // If the sphere is fully behind the near plane, it cannot affect any visible fragment.
    if (view4.z + radius_ws <= near_z) return false;

    // SHS uses LH view space (+Z forward), so front-facing depth is +view4.z.
    view_depth = max(near_z, view4.z);
    vec4 clip = ubo.proj * view4;
    // Near-plane intersections are numerically unstable in screen-space bounds
    // (especially for large radii and clipped spheres). Use a conservative
    // fallback for tiled modes to avoid false negatives / light popping.
    if (clip.w <= 1e-6 || (view4.z - radius_ws) <= near_z)
    {
        center_px = vec2(float(width) * 0.5, float(height) * 0.5);
        radius_px = float(max(width, height));
        return true;
    }

    vec2 ndc = clip.xy / clip.w;
    center_px.x = (ndc.x * 0.5 + 0.5) * float(width);
    center_px.y = (0.5 - ndc.y * 0.5) * float(height);
    radius_px = abs(radius_ws * ubo.proj[1][1] * float(height) / view_depth);
    // Conservative inflation to avoid tile-boundary under-coverage
    // (common source of blocky lighting with tiled/clustered lists).
    float perspective_inflate = 1.0 + clamp(radius_ws / max(view_depth, near_z), 0.0, 2.5) * 0.65;
    radius_px = radius_px * perspective_inflate + 4.0;
    return true;
}

void tile_screen_bounds(uint tile_x, uint tile_y, uint tile_size, uint width, uint height, out vec2 tile_min, out vec2 tile_max)
{
    tile_min = vec2(float(tile_x * tile_size), float(tile_y * tile_size));
    tile_max = vec2(
        float(min((tile_x + 1u) * tile_size, width)),
        float(min((tile_y + 1u) * tile_size, height))
    );
}

void cluster_slice_depth_bounds(uint z_slice, uint z_slices, out float out_near, out float out_far)
{
    float near_z = max(ubo.depth_params.x, 0.001);
    float far_z = max(ubo.depth_params.y, near_z + 0.01);
    float slice0 = float(z_slice) / float(z_slices);
    float slice1 = float(z_slice + 1u) / float(z_slices);
    out_near = near_z * pow(far_z / near_z, slice0);
    out_far = near_z * pow(far_z / near_z, slice1);
}

void main()
{
    uint tile_x = gl_GlobalInvocationID.x;
    uint tile_y = gl_GlobalInvocationID.y;
    uint tile_z = gl_GlobalInvocationID.z;

    uint width = max(ubo.screen_tile_lightcount.x, 1u);
    uint height = max(ubo.screen_tile_lightcount.y, 1u);
    uint tiles_x = max(ubo.screen_tile_lightcount.z, 1u);
    uint light_count = ubo.screen_tile_lightcount.w;
    uint tiles_y = max(ubo.params.x, 1u);
    uint max_per_tile = max(ubo.params.y, 1u);
    uint tile_size = max(ubo.params.z, 1u);
    uint culling_mode = ubo.params.w;
    uint z_slices = max(ubo.culling_params.x, 1u);

    if (tile_x >= tiles_x || tile_y >= tiles_y) return;
    if (culling_mode == 3u && tile_z >= z_slices) return;

    uint list_id = tile_y * tiles_x + tile_x;
    if (culling_mode == 3u)
    {
        list_id = (tile_z * tiles_y + tile_y) * tiles_x + tile_x;
    }
    uint base_index = list_id * max_per_tile;
    tile_counts[list_id] = 0u;

    vec2 tile_min = vec2(0.0);
    vec2 tile_max = vec2(0.0);
    tile_screen_bounds(tile_x, tile_y, tile_size, width, height, tile_min, tile_max);

    uint count = 0u;
    float cluster_near = 0.0;
    float cluster_far = 0.0;
    if (culling_mode == 3u)
    {
        cluster_slice_depth_bounds(tile_z, z_slices, cluster_near, cluster_far);
    }

    vec2 tile_view_depth_range = vec2(0.0);
    if (culling_mode == 2u)
    {
        float near_z = max(ubo.depth_params.x, 0.001);
        float far_z = max(ubo.depth_params.y, near_z + 0.01);
        uint tile_id = tile_y * tiles_x + tile_x;
        tile_view_depth_range = tile_depth_ranges[tile_id];
        // (0,0) is the explicit "no depth samples" sentinel from depth reduction.
        if (tile_view_depth_range.x <= 0.0 && tile_view_depth_range.y <= 0.0)
        {
            // Fall back to full camera depth span for uncovered/invalid tiles so
            // lighting remains stable instead of blinking off by tile.
            tile_view_depth_range = vec2(near_z, far_z);
        }
        tile_view_depth_range.x = clamp(tile_view_depth_range.x, near_z, far_z);
        tile_view_depth_range.y = clamp(tile_view_depth_range.y, near_z, far_z);
        float depth_expand = max(0.05, tile_view_depth_range.y * 0.0015);
        tile_view_depth_range.x = clamp(tile_view_depth_range.x - depth_expand, near_z, far_z);
        tile_view_depth_range.y = clamp(tile_view_depth_range.y + depth_expand, near_z, far_z);
        // Flat tiles are valid (min == max). Expand slightly to avoid zero-width depth intervals.
        if (tile_view_depth_range.y < tile_view_depth_range.x) tile_view_depth_range.y = tile_view_depth_range.x;
        tile_view_depth_range.y = min(far_z, max(tile_view_depth_range.y, tile_view_depth_range.x + max(0.02, tile_view_depth_range.x * 0.0005)));
    }

    for (uint i = 0u; i < light_count; ++i)
    {
        CullingLightGPU light = light_buffer.lights[i];
        uint flags = light.type_shape_flags.z;
        if ((flags & SHS_LIGHT_FLAG_ENABLED) == 0u) continue;

        vec4 cull_sphere = resolve_cull_sphere(light);
        vec2 screen = vec2(0.0);
        float radius_px = 0.0;
        float view_depth = 0.0;
        if (!project_light_screen(cull_sphere.xyz, cull_sphere.w, width, height, screen, radius_px, view_depth)) continue;

        const float screen_pad_px = 16.0;
        if ((screen.x + radius_px + screen_pad_px) < tile_min.x) continue;
        if ((screen.y + radius_px + screen_pad_px) < tile_min.y) continue;
        if ((screen.x - radius_px - screen_pad_px) > tile_max.x) continue;
        if ((screen.y - radius_px - screen_pad_px) > tile_max.y) continue;

        if (culling_mode == 2u)
        {
            // Keep depth-range test conservative; false negatives are much worse
            // than extra lights in stress/demo mode.
            const float depth_pad = max(1.0, max(cull_sphere.w * 0.35, view_depth * 0.03));
            float light_min = view_depth - cull_sphere.w - depth_pad;
            float light_max = view_depth + cull_sphere.w + depth_pad;
            if (light_max < tile_view_depth_range.x || light_min > tile_view_depth_range.y)
            {
                // Very large projected lights are kept to avoid patch artifacts on broad surfaces.
                if (radius_px < float(tile_size) * 4.0) continue;
            }
        }
        else if (culling_mode == 3u)
        {
            const float depth_pad = max(0.8, max(cull_sphere.w * 0.25, view_depth * 0.02));
            float light_min = view_depth - cull_sphere.w - depth_pad;
            float light_max = view_depth + cull_sphere.w + depth_pad;
            if (light_max < cluster_near || light_min > cluster_far)
            {
                if (radius_px < float(tile_size) * 4.0) continue;
            }
        }
        else if (culling_mode == 0u)
        {
            // No culling mode: fragment shader will run brute-force loop.
            continue;
        }

        if (count < max_per_tile)
        {
            tile_indices[base_index + count] = i;
            ++count;
        }
    }

    tile_counts[list_id] = count;
}
